*Jules, This is the original file that you refactored ealier. This is for reference only.

init python:
    from collections import namedtuple
    Zone = namedtuple("Zone", "x y width height")

    touch_zones = {
        1: { "zone1": Zone(0, 0, 100, 100) },
        2: { "zone1": Zone(50, 50, 100, 100) },
        3: { "zone1": Zone(100, 100, 100, 100) },
        4: { "zone1": Zone(150, 150, 100, 100) },
        5: { "zone1": Zone(200, 200, 100, 100) },
    }

    thresholds = {
        1: { "zone1": 5 },
        2: { "zone1": 5 },
        3: { "zone1": 5 },
        4: { "zone1": 5 },
        5: { "zone1": 5 },
    }

    puzzle_times = {
        1: 30,
        2: 30,
        3: 30,
        4: 30,
        5: 30,
    }


screen TouchScreen(puzzle_number):
    # CUTSCENE FIX: Consolidated touch screen for all puzzles
    default zones = touch_zones[puzzle_number]
    key "mouseup_1" action Function(process_touch, puzzle_number)

    for zone_id, zone in zones.items():
        imagemap:
            idle None
            hover None
            hotspot (zone.x, zone.y, zone.width, zone.height) action Function(process_zone, puzzle_number, zone_id)  # CUTSCENE FIX

init python:
    # CUTSCENE FIX: Generalized Puzzle class
    class Puzzle(object):
        def __init__(self, puzzle_number, zones, thresholds, max_time):
            self.number = puzzle_number
            self.zones = zones
            self.thresholds = thresholds
            self.max_time = max_time
            self.timer = 0
            self.state = {}
            for zid in zones:
                self.state[zid] = 0

        def update(self, dt):
            self.timer += dt
            if self.timer > self.max_time:
                return 'timeout'
            for zid, amount in self.state.items():
                if amount >= self.thresholds.get(zid, float('inf')):
                    return 'complete'
            return None

        def process_zone(self, zone_id, amount):
            # CUTSCENE FIX: accumulate input in corresponding zone
            if zone_id in self.state:
                self.state[zone_id] += amount

        def is_over(self):
            status = self.update(0)
            return status in ('timeout', 'complete')

    puzzles = {}
    for num in range(1,6):
        puzzles[num] = Puzzle(
            puzzle_number=num,
            zones=touch_zones[num],
            thresholds=thresholds[num],
            max_time=puzzle_times[num]
        )

# IMAGE DEFINITIONS

image Hearts_A = "images/Hearts_A.png"
image Hearts_B = "images/Hearts_B.png"
image Hearts_C = "images/Hearts_C.png"
image Hearts_D = "images/Hearts_D.png"
image Excitement_A = "images/Excitement_A.png"
image Excitement_B = "images/Excitement_B.png"
image Excitement_C = "images/Excitement_C.png"
image Excitement_D = "images/Excitement_D.png"
image Excitement_E = "images/Excitement_E.png"
image Excitement_F = "images/Excitement_F.png"
image Trust_A = "images/Trust_A.png"
image Trust_B = "images/Trust_B.png"
image Trust_C = "images/Trust_C.png"
image Trust_D = "images/Trust_D.png"
image Trust_E = "images/Trust_E.png"
image Trust_F = "images/Trust_F.png"

# GLOBAL STATE & CONFIGURATION

init python:
    import random, time, pygame

    # Global Player State
    class JailyState:
        def __init__(self):
            self.trust = 50
            self.excitement = 50
            self.hearts = 50  # New stat for hearts particles.
            self.temperature = 98.6
            self.embarrassment = 50
            self.game_over = False

    jaily = JailyState()

    # Adjustable Configuration

    adjustable_config = {
        "cooldown_duration": 1.0,             # Cooldown after correct step
        "required_hold_time": 10.0,           # Time required to hold a zone
        "wrong_grace_period": 5.0,
        "wrong_transition_duration": 1.0,     # Transition time for wrong input penalty
        "penalty_excitement_rate": 0.05,
        "penalty_trust_rate": 0.05,
        "penalty_embarrassment_rate": 0.05,

        # EXCITEMENT CONFIG
        "excitement_increase_rate": 0.02,
        "excitement_decay_rate": 0.01,
        "excitement_stat_baseline": 50,
        "excitement_multiplier_at_min": 0.5,
        "excitement_multiplier_at_max": 1.5,

        # TRUST CONFIG
        "trust_increase_rate": 0.0075,
        "trust_decay_rate": 0.005,
        "trust_stat_baseline": 50,
        "trust_multiplier_at_min": 0.25,
        "trust_multiplier_at_max": 2.0,
        "trust_particle_phase_offset": 0.5,

        # Hearts Particle CONFIG
        "hearts_threshold": 25,
        "hearts_lower_bound": 30,
        "hearts_upper_bound": 100,
        "pps_at_lower_bound_hearts": 0.5,
        "pps_at_upper_bound_hearts": 10.0,

        # Trust Particle Ranges
        "trust_threshold": 31,
        "trust_lower_bound": 51,
        "trust_upper_bound": 100,
        "pps_at_lower_bound_trust": 0.20,
        "pps_at_upper_bound_trust": 0.5,

        # Excitement Particle Ranges
        "excitement_threshold": 25,
        "excitement_lower_bound": 30,
        "excitement_upper_bound": 100,
        "pps_at_lower_bound": 0.20,
        "pps_at_upper_bound": 0.5,

        "particle_transition_duration": 5.0,  # How long it takes to adjust particle rate
        "particle_update_interval": 0.016,    # Particle update frequency (~60fps)

        # Temperature Config
        "temp_embarrassment_multiplier": 4.0,
        "temp_incr_rate": 0.05,
        "temp_decay_rate": 0.0025,
        "cooldown_zone_temp_reduction_rate": 0.5,
        "cooldown_zone_excitement_increase_rate": -2.0,
        "chill_penalty_temp_cooldown_rate": 0.2,
        "chill_penalty_excitement_decay_rate": 5.0,
        "chill_penalty_trust_decay_rate": 5.0,
        "temp_lower_game_over": 97.5,

        # Heart shower adjustable attributes
        "heart_shower": {
            "duration": 3.0,            # Duration in seconds for the shower animation
            "heart_count": 100,         # Number of hearts spawned
            "x_start_min": -100,        # Minimum starting x position
            "x_start_max": 2020,         # Maximum starting x position
            "y_start_min": -200,        # Minimum starting y position
            "y_start_max": 0,           # Maximum starting y position
            "x_end_min": -100,          # Minimum ending x position
            "x_end_max": 2020,           # Maximum ending x position
            "y_end_min": 1180,          # Minimum ending y position
            "y_end_max": 2400,           # Maximum ending y position
            "rotation_min": -30,        # Minimum rotation in degrees
            "rotation_max": 30,         # Maximum rotation in degrees
            "scale_min": 0.75,          # Minimum scale factor
            "scale_max": 3.0            # Maximum scale factor
        }
    }

    # Precomputed Heart Shower Animation Data
    heart_shower_anim = []
    def init_heart_shower_anim():
        global heart_shower_anim
        hs = adjustable_config["heart_shower"]
        heart_shower_anim = []
        for i in range(hs["heart_count"]):
            data = {}
            data["x_start"] = random.randint(hs["x_start_min"], hs["x_start_max"])
            data["y_start"] = random.randint(hs["y_start_min"], hs["y_start_max"])
            data["x_end"] = random.randint(hs["x_end_min"], hs["x_end_max"])
            data["y_end"] = random.randint(hs["y_end_min"], hs["y_end_max"])
            data["r_rotate"] = random.randint(hs["rotation_min"], hs["rotation_max"])
            data["r_scale"] = random.uniform(hs["scale_min"], hs["scale_max"])
            data["heart_img"] = random.choice(["Hearts_A", "Hearts_B"])
            heart_shower_anim.append(data)

    # Particle Spawn Rate Functions
    def compute_pps(excitement):
        if excitement <= adjustable_config["excitement_threshold"]:
            return 0.0
        elif excitement < adjustable_config["excitement_lower_bound"]:
            return ((excitement - adjustable_config["excitement_threshold"]) /
                    (adjustable_config["excitement_lower_bound"] - adjustable_config["excitement_threshold"])
                   ) * adjustable_config["pps_at_lower_bound"]
        else:
            ratio = (excitement - adjustable_config["excitement_lower_bound"]) / (adjustable_config["excitement_upper_bound"] - adjustable_config["excitement_lower_bound"])
            return adjustable_config["pps_at_lower_bound"] + ratio * (adjustable_config["pps_at_upper_bound"] - adjustable_config["pps_at_lower_bound"])

    def compute_trust_pps(trust):
        if trust <= adjustable_config["trust_threshold"]:
            return 0.0
        elif trust < adjustable_config["trust_lower_bound"]:
            return ((trust - adjustable_config["trust_threshold"]) /
                    (adjustable_config["trust_lower_bound"] - adjustable_config["trust_threshold"])
                   ) * adjustable_config["pps_at_lower_bound_trust"]
        else:
            ratio = (trust - adjustable_config["trust_lower_bound"]) / (adjustable_config["trust_upper_bound"] - adjustable_config["trust_lower_bound"])
            return adjustable_config["pps_at_lower_bound_trust"] + ratio * (adjustable_config["pps_at_upper_bound_trust"] - adjustable_config["pps_at_lower_bound_trust"])

    def compute_hearts_pps(hearts):
        if hearts <= adjustable_config["hearts_threshold"]:
            return 0.0
        elif hearts < adjustable_config["hearts_lower_bound"]:
            return ((hearts - adjustable_config["hearts_threshold"]) /
                    (adjustable_config["hearts_lower_bound"] - adjustable_config["hearts_threshold"])
                   ) * adjustable_config["pps_at_lower_bound_hearts"]
        else:
            ratio = (hearts - adjustable_config["hearts_lower_bound"]) / (adjustable_config["hearts_upper_bound"] - adjustable_config["hearts_lower_bound"])
            return adjustable_config["pps_at_lower_bound_hearts"] + ratio * (adjustable_config["pps_at_upper_bound_hearts"] - adjustable_config["pps_at_lower_bound_hearts"])

    # Particle Configurations and Lists
    particles = []              # For heart particles.
    excitement_particles = []   # For excitement particles.
    trust_particles = []        # For trust particles.

    particle_config = {
        "particles_per_sec": 0,
        "lifetime": 1.1,
        "fadeout_start": 0.1,
        "size_range": (0.9, 1.25),
        "size_multiplier": 1.0,
        "rotation_range": (-45, 45),
        "spread_range": (-150, 150)
    }

    particle_config_excitement = {
        "particles_per_sec": 0,
        "lifetime": 2.5,
        "fadeout_start": 2.0,
        "size_range": (0.9, 1.1),
        "size_multiplier": 0.75,
        "rotation_range": (-7, 7),
        "spread_range": (-200, 200)
    }

    particle_config_trust = {
        "particles_per_sec": 0,
        "lifetime": 2.5,
        "fadeout_start": 2.0,
        "size_range": (0.9, 1.1),
        "size_multiplier": 0.75,
        "rotation_range": (-7, 7),
        "spread_range": (-200, 200)
    }

    # Input Flags
    clicked_zone1 = False
    clicked_zone2 = False
    clicked_locked1 = False
    clicked_cooldown = False

    # New input flags for additional puzzles:
    clicked_locked2 = False

    clicked_zone3 = False
    clicked_zone4 = False
    clicked_locked3 = False
    clicked_locked4 = False
    clicked_locked5 = False

    clicked_zone5 = False
    clicked_zone6 = False
    clicked_locked6 = False
    clicked_locked7 = False
    clicked_locked8 = False
    clicked_locked9 = False

    clicked_zone7 = False
    clicked_zone8 = False
    clicked_locked10 = False
    clicked_locked11 = False
    clicked_locked12 = False
    clicked_locked13 = False
    clicked_locked14 = False

    wrong_input_active = False
    wrong_input_start_time = None
    penalty_active = False

    # Mouse and Interaction Helpers
    def left_mouse_down():
        return pygame.mouse.get_pressed()[0]

    def is_interacting():
        # This function should check all relevant zone variables.
        return ((clicked_zone1 or clicked_zone2 or clicked_zone3 or clicked_zone4 or
                 clicked_zone5 or clicked_zone6 or clicked_zone7 or clicked_zone8 or
                 clicked_locked1 or clicked_locked2 or clicked_locked3 or clicked_locked4 or
                 clicked_locked5 or clicked_locked6 or clicked_locked7 or clicked_locked8 or
                 clicked_locked9 or clicked_locked10 or clicked_locked11 or clicked_locked12 or
                 clicked_locked13 or clicked_locked14) and left_mouse_down())

    def get_hotzone_multiplier():
        baseline = adjustable_config["excitement_stat_baseline"]
        min_mult = adjustable_config["excitement_multiplier_at_min"]
        max_mult = adjustable_config["excitement_multiplier_at_max"]
        excitement = jaily.excitement
        if excitement <= baseline:
            return min_mult + (excitement / baseline) * (1.0 - min_mult)
        else:
            return 1.0 + ((excitement - baseline) / (100 - baseline)) * (max_mult - 1.0)

    def get_trust_penalty_multiplier():
        baseline = adjustable_config["trust_stat_baseline"]
        min_mult = adjustable_config["trust_multiplier_at_min"]
        max_mult = adjustable_config["trust_multiplier_at_max"]
        trust = jaily.trust
        if trust <= baseline:
            return max_mult + (trust / baseline) * (1.0 - max_mult)
        else:
            return 1.0 + ((trust - baseline) / (100 - baseline)) * (min_mult - 1.0)

    # Global Stats Update Function
    def update_stats(interacting):
        global penalty_active, wrong_input_active, wrong_input_start_time
        current_time = time.time()
        dt = current_time - update_stats.last_time
        update_stats.last_time = current_time

        dTemp = adjustable_config["temp_incr_rate"] * (1.0 if interacting else 0.0) - adjustable_config["temp_decay_rate"] * (jaily.temperature - 98.6)
        embarrassment_factor = (jaily.embarrassment / 100) * adjustable_config["temp_embarrassment_multiplier"]
        dTemp *= embarrassment_factor
        jaily.temperature += dTemp * dt

        if penalty_active:
            trust_multiplier = get_trust_penalty_multiplier()
            dExc = -adjustable_config["penalty_excitement_rate"] * jaily.excitement * trust_multiplier
            dTrust = -adjustable_config["penalty_trust_rate"] * jaily.trust * trust_multiplier
            dEmb = adjustable_config["penalty_embarrassment_rate"] * 100 * trust_multiplier
            jaily.excitement += dExc * dt
            jaily.trust += dTrust * dt
            jaily.embarrassment += dEmb * dt
        else:
            if wrong_input_active and wrong_input_start_time is not None:
                wrong_elapsed = current_time - wrong_input_start_time
                if wrong_elapsed < adjustable_config["wrong_grace_period"]:
                    factor = 1.0
                elif wrong_elapsed < adjustable_config["wrong_grace_period"] + (adjustable_config["wrong_transition_duration"] / get_hotzone_multiplier()):
                    factor = 1.0 - 2.0 * ((wrong_elapsed - adjustable_config["wrong_grace_period"]) / (adjustable_config["wrong_transition_duration"] / get_hotzone_multiplier()))
                else:
                    factor = -1.0
                I = factor
            else:
                I = 1.0 if interacting else 0.0

            fTemp = 1 + (jaily.temperature - 98.6) / (103.0 - 98.6)
            dExc = adjustable_config["excitement_increase_rate"] * jaily.trust * I * fTemp - adjustable_config["excitement_decay_rate"] * jaily.excitement
            jaily.excitement += dExc * dt
            dTrust = adjustable_config["trust_increase_rate"] * jaily.excitement * I * fTemp - adjustable_config["trust_decay_rate"] * (jaily.trust - adjustable_config["trust_stat_baseline"])
            jaily.trust += dTrust * dt
            if jaily.trust > 100:
                jaily.trust = 100

        if jaily.excitement > 100:
            jaily.excitement = 100

        if clicked_cooldown and left_mouse_down():
            if jaily.temperature > 98.5:
                jaily.temperature -= adjustable_config["cooldown_zone_temp_reduction_rate"] * dt
                jaily.excitement += adjustable_config["cooldown_zone_excitement_increase_rate"] * dt
            else:
                jaily.temperature -= adjustable_config["chill_penalty_temp_cooldown_rate"] * dt
                jaily.excitement -= adjustable_config["chill_penalty_excitement_decay_rate"] * dt
                jaily.trust -= adjustable_config["chill_penalty_trust_decay_rate"] * dt

        if (jaily.temperature >= 103.0 or jaily.embarrassment >= 100 or
            jaily.trust <= 0 or jaily.excitement <= 0 or
            jaily.temperature <= adjustable_config["temp_lower_game_over"]):
            jaily.game_over = True

    update_stats.last_time = time.time()

    # Particle Functions
    def spawn_particle(pos):
        p = {}
        if penalty_active or (wrong_input_active and wrong_input_start_time and (time.time() - wrong_input_start_time >= adjustable_config["wrong_grace_period"])):
            p['heart'] = random.choice(["Hearts_C", "Hearts_D"])
        else:
            p['heart'] = random.choice(["Hearts_A", "Hearts_B"])
        p['x'] = pos[0] + random.randint(*particle_config["spread_range"])
        p['y'] = pos[1] + random.randint(*particle_config["spread_range"])
        p['zoom'] = random.uniform(*particle_config["size_range"]) * particle_config["size_multiplier"]
        p['rotate'] = random.randint(*particle_config["rotation_range"])
        p['spawn_time'] = time.time()
        particles.append(p)

    def spawn_excitement_particle(pos):
        p = {}
        exp = jaily.excitement
        if 55 <= exp <= 74:
            p['image'] = random.choice(["Excitement_A", "Excitement_B"])
        elif 75 <= exp <= 94:
            p['image'] = random.choice(["Excitement_C", "Excitement_D"])
        elif 95 <= exp <= 100:
            p['image'] = random.choice(["Excitement_E", "Excitement_F"])
        else:
            return
        p['x'] = pos[0] + random.randint(*particle_config_excitement["spread_range"])
        p['y'] = pos[1] + random.randint(*particle_config_excitement["spread_range"])
        p['zoom'] = random.uniform(*particle_config_excitement["size_range"]) * particle_config_excitement["size_multiplier"]
        p['rotate'] = random.randint(*particle_config_excitement["rotation_range"])
        p['spawn_time'] = time.time()
        excitement_particles.append(p)

    def spawn_trust_particle(pos):
        p = {}
        tr = jaily.trust
        ab_low, ab_high = adjustable_config.get("trust_range_ab", (55, 74))
        cd_low, cd_high = adjustable_config.get("trust_range_cd", (75, 94))
        ef_low, ef_high = adjustable_config.get("trust_range_ef", (95, 100))
        if ab_low <= tr <= ab_high:
            p['image'] = random.choice(["Trust_A", "Trust_B"])
        elif cd_low <= tr <= cd_high:
            p['image'] = random.choice(["Trust_C", "Trust_D"])
        elif ef_low <= tr <= ef_high:
            p['image'] = random.choice(["Trust_E", "Trust_F"])
        else:
            return
        p['x'] = pos[0] + random.randint(*particle_config_trust["spread_range"])
        p['y'] = pos[1] + random.randint(*particle_config_trust["spread_range"])
        p['zoom'] = random.uniform(*particle_config_trust["size_range"]) * particle_config_trust["size_multiplier"]
        p['rotate'] = random.randint(*particle_config_trust["rotation_range"])
        p['spawn_time'] = time.time()
        trust_particles.append(p)

    def cleanup_particles():
        now = time.time()
        particles[:] = [p for p in particles if now - p['spawn_time'] < particle_config["lifetime"]]
        excitement_particles[:] = [p for p in excitement_particles if now - p['spawn_time'] < particle_config_excitement["lifetime"]]
        trust_particles[:] = [p for p in trust_particles if now - p['spawn_time'] < particle_config_trust["lifetime"]]

    # Particle Manager Class
    class ParticleManager:
        def __init__(self):
            self.heart_accumulator = 0.0
            self.excitement_accumulator = 0.0
            initial_trust_pps = compute_trust_pps(jaily.trust)
            if initial_trust_pps > 0:
                initial_spawn_interval = 1.0 / initial_trust_pps
                self.trust_accumulator = initial_spawn_interval * adjustable_config["trust_particle_phase_offset"]
            else:
                self.trust_accumulator = 0.0
            self.last_time = time.time()

        def update(self):
            current_time = time.time()
            dt = current_time - self.last_time

            if (clicked_zone1 or clicked_zone2 or clicked_zone3 or clicked_zone4 or
                clicked_zone5 or clicked_zone6 or clicked_zone7 or clicked_zone8 or
                clicked_locked1 or clicked_locked2 or clicked_locked3 or clicked_locked4 or
                clicked_locked5 or clicked_locked6 or clicked_locked7 or clicked_locked8 or
                clicked_locked9 or clicked_locked10 or clicked_locked11 or clicked_locked12 or
                clicked_locked13 or clicked_locked14 or clicked_cooldown) and left_mouse_down():
                self.heart_accumulator += dt
                spawn_interval = 1.0 / max(1e-6, particle_config["particles_per_sec"])
                while self.heart_accumulator >= spawn_interval:
                    spawn_particle(renpy.get_mouse_pos())
                    self.heart_accumulator -= spawn_interval

                if 55 <= jaily.excitement <= 100:
                    self.excitement_accumulator += dt
                    spawn_interval_excitement = 1.0 / max(1e-6, particle_config_excitement["particles_per_sec"])
                    while self.excitement_accumulator >= spawn_interval_excitement:
                        spawn_excitement_particle(renpy.get_mouse_pos())
                        self.excitement_accumulator -= spawn_interval_excitement
                else:
                    self.excitement_accumulator = 0.0

                if 55 <= jaily.trust <= 100:
                    self.trust_accumulator += dt
                    spawn_interval_trust = 1.0 / max(1e-6, particle_config_trust["particles_per_sec"])
                    while self.trust_accumulator >= spawn_interval_trust:
                        spawn_trust_particle(renpy.get_mouse_pos())
                        self.trust_accumulator -= spawn_interval_trust
                else:
                    self.trust_accumulator = 0.0
            else:
                self.heart_accumulator = 0.0
                self.excitement_accumulator = 0.0
                self.trust_accumulator = 0.0

            target_hearts_particles = compute_hearts_pps(jaily.hearts)
            current_hearts_particles = particle_config["particles_per_sec"]
            transition_rate_hearts = adjustable_config["pps_at_lower_bound_hearts"] / adjustable_config["particle_transition_duration"]
            if current_hearts_particles < target_hearts_particles:
                current_hearts_particles = min(target_hearts_particles, current_hearts_particles + transition_rate_hearts * dt)
            elif current_hearts_particles > target_hearts_particles:
                current_hearts_particles = max(target_hearts_particles, current_hearts_particles - transition_rate_hearts * dt)
            particle_config["particles_per_sec"] = current_hearts_particles

            target_particles = compute_pps(jaily.excitement)
            current_particles = particle_config_excitement["particles_per_sec"]
            transition_rate = adjustable_config["pps_at_lower_bound"] / adjustable_config["particle_transition_duration"]
            if current_particles < target_particles:
                current_particles = min(target_particles, current_particles + transition_rate * dt)
            elif current_particles > target_particles:
                current_particles = max(target_particles, current_particles - transition_rate * dt)
            particle_config_excitement["particles_per_sec"] = current_particles

            target_trust_particles = compute_trust_pps(jaily.trust)
            current_trust_particles = particle_config_trust["particles_per_sec"]
            transition_rate_trust = adjustable_config["pps_at_lower_bound_trust"] / adjustable_config["particle_transition_duration"]
            if current_trust_particles < target_trust_particles:
                current_trust_particles = min(target_trust_particles, current_trust_particles + transition_rate_trust * dt)
            elif current_trust_particles > target_trust_particles:
                current_trust_particles = max(target_trust_particles, current_trust_particles - transition_rate_trust * dt)
            particle_config_trust["particles_per_sec"] = current_trust_particles

            self.last_time = current_time

    particle_manager = ParticleManager()

    def update_particle_system():
        particle_manager.update()

    # Puzzle Logic
    class Puzzle:
        def __init__(self):
            self.sequence = ["zone1", "zone2", "zone1", "zone2", "zone2", "locked1", "zone1", "locked1", "zone2", "locked1"]
            self.current_seq_index = 0
            self.hold_start_time = {"zone1": None, "zone2": None, "locked1": None}
            self.ne1_unlocked = False
            self.current_active_zone = None
            self.cooldown_end = 0.0
            self.last_particle_update = time.time()
            self.initial_touch_spawned = False
            self.initial_touch_spawned_cooldown = False

        def process_zone(self, zone, now, expected_zone):
            if self.current_active_zone == zone and zone == expected_zone:
                if self.hold_start_time[zone] is None:
                    self.hold_start_time[zone] = now
                elif now - self.hold_start_time[zone] >= adjustable_config["required_hold_time"] / get_hotzone_multiplier():
                    self.hold_start_time[zone] = None
                    return True
            else:
                self.hold_start_time[zone] = None
            return False

        def rub_timer(self):
            global wrong_input_active, wrong_input_start_time, penalty_active
            now = time.time()
            if now < self.cooldown_end:
                self.current_active_zone = None
                wrong_input_active = False
                wrong_input_start_time = None
                penalty_active = False
                # Reset hold timers after cooldown to prevent stale hold counts
                for zone in self.hold_start_time:
                    self.hold_start_time[zone] = None
                return
            # === Prevent clicking cooldown zone from affecting puzzle ===
            if clicked_cooldown and left_mouse_down():
                self.current_active_zone = None
                wrong_input_active = False
                wrong_input_start_time = None
                penalty_active = False
                return

            expected_zone = self.sequence[self.current_seq_index] if self.current_seq_index < len(self.sequence) else None

            var_previous_zone = self.current_active_zone
            new_active_zone = None
            if left_mouse_down():
                # Check all possible zone variables according to the active puzzle.
                if clicked_zone1:
                    new_active_zone = "zone1"
                elif clicked_zone2:
                    new_active_zone = "zone2"
                elif clicked_zone3:
                    new_active_zone = "zone3"
                elif clicked_zone4:
                    new_active_zone = "zone4"
                elif clicked_zone5:
                    new_active_zone = "zone5"
                elif clicked_zone6:
                    new_active_zone = "zone6"
                elif clicked_zone7:
                    new_active_zone = "zone7"
                elif clicked_zone8:
                    new_active_zone = "zone8"
                elif clicked_locked1:
                    new_active_zone = "locked1"
                elif clicked_locked2:
                    new_active_zone = "locked2"
                elif clicked_locked3:
                    new_active_zone = "locked3"
                elif clicked_locked4:
                    new_active_zone = "locked4"
                elif clicked_locked5:
                    new_active_zone = "locked5"
                elif clicked_locked6:
                    new_active_zone = "locked6"
                elif clicked_locked7:
                    new_active_zone = "locked7"
                elif clicked_locked8:
                    new_active_zone = "locked8"
                elif clicked_locked9:
                    new_active_zone = "locked9"
                elif clicked_locked10:
                    new_active_zone = "locked10"
                elif clicked_locked11:
                    new_active_zone = "locked11"
                elif clicked_locked12:
                    new_active_zone = "locked12"
                elif clicked_locked13:
                    new_active_zone = "locked13"
                elif clicked_locked14:
                    new_active_zone = "locked14"
            else:
                new_active_zone = None

            changed_zone = (new_active_zone != var_previous_zone)
            self.current_active_zone = new_active_zone

            for zone_key in list(self.hold_start_time.keys()):
                if zone_key not in self.sequence:
                    self.hold_start_time[zone_key] = None

            if self.current_active_zone and not self.current_active_zone.startswith("locked") and self.process_zone(self.current_active_zone, now, expected_zone):
                self.current_seq_index += 1
                self.cooldown_end = now + adjustable_config["cooldown_duration"] / get_hotzone_multiplier()
                init_heart_shower_anim()
                renpy.show_screen("FlashScreen")

            elif self.current_active_zone and self.current_active_zone.startswith("locked"):
                if expected_zone == self.current_active_zone:
                    if self.hold_start_time[self.current_active_zone] is None:
                        self.hold_start_time[self.current_active_zone] = now
                    elif now - self.hold_start_time[self.current_active_zone] >= adjustable_config["required_hold_time"] / get_hotzone_multiplier():
                        self.current_seq_index += 1
                        self.cooldown_end = now + adjustable_config["cooldown_duration"] / get_hotzone_multiplier()
                        init_heart_shower_anim()
                        renpy.show_screen("FlashScreen")
                        self.hold_start_time[self.current_active_zone] = None
                    penalty_active = False
                else:
                    self.hold_start_time[self.current_active_zone] = None
                    penalty_active = False
            else:
                penalty_active = False

            if left_mouse_down() and self.current_active_zone is not None and self.current_active_zone != expected_zone:
                if wrong_input_start_time is None:
                    wrong_input_start_time = now
                wrong_input_active = True
            else:
                wrong_input_active = False
                wrong_input_start_time = None

            dt_particles = now - self.last_particle_update
            target_particles = compute_pps(jaily.excitement)
            current_particles = particle_config_excitement["particles_per_sec"]
            transition_rate = adjustable_config["pps_at_lower_bound"] / adjustable_config["particle_transition_duration"]
            if current_particles < target_particles:
                current_particles = min(target_particles, current_particles + transition_rate * dt_particles)
            elif current_particles > target_particles:
                current_particles = max(target_particles, current_particles - transition_rate * dt_particles)
            particle_config_excitement["particles_per_sec"] = current_particles
            self.last_particle_update = now

            if changed_zone:
                if self.current_active_zone is not None and not self.initial_touch_spawned:
                    spawn_particle(renpy.get_mouse_pos())
                    self.initial_touch_spawned = True
                if self.current_active_zone is None:
                    self.initial_touch_spawned = False

            if clicked_cooldown and left_mouse_down():
                if not self.initial_touch_spawned_cooldown:
                    spawn_particle(renpy.get_mouse_pos())
                    self.initial_touch_spawned_cooldown = True
            else:
                self.initial_touch_spawned_cooldown = False

        def update(self):
            self.rub_timer()
            update_stats(is_interacting())

        def reset(self):
            self.current_seq_index = 0
            self.hold_start_time = {"zone1": None, "zone2": None, "zone3": None, "zone4": None,
                                    "zone5": None, "zone6": None, "zone7": None, "zone8": None,
                                    "locked1": None, "locked2": None, "locked3": None, "locked4": None,
                                    "locked5": None, "locked6": None, "locked7": None, "locked8": None,
                                    "locked9": None, "locked10": None, "locked11": None, "locked12": None,
                                    "locked13": None, "locked14": None}
            self.ne1_unlocked = False
            self.current_active_zone = None
            global wrong_input_active, wrong_input_start_time, penalty_active
            wrong_input_active = False
            wrong_input_start_time = None
            penalty_active = False
            update_stats.last_time = time.time()
            self.cooldown_end = 0.0
            self.last_particle_update = time.time()
            self.initial_touch_spawned = False
            self.initial_touch_spawned_cooldown = False
            particles[:] = []
            excitement_particles[:] = []
            trust_particles[:] = []

    # New Puzzle classes

    class Puzzle2(Puzzle):
        def __init__(self):
            super(Puzzle2, self).__init__()
            self.sequence = ["zone2", "zone2", "zone1", "zone1", "locked1", "zone1", "zone2", "locked1", "locked1", "locked2", "zone1", "zone2", "locked2"]

    class Puzzle3(Puzzle):
        def __init__(self):
            super(Puzzle3, self).__init__()
            self.sequence = ["zone3", "zone3", "zone4", "zone3", "locked3", "zone4", "locked3", "zone4", "zone3", "locked4", "zone4", "locked3", "zone3", "locked4", "locked5", "zone4", "zone3", "locked5", "locked5"]

    class Puzzle4(Puzzle):
        def __init__(self):
            super(Puzzle4, self).__init__()
            self.sequence = ["zone5", "zone6", "zone6", "zone5", "locked6", "zone6", "zone5", "locked6", "locked7", "zone5", "locked7", "locked7", "zone6", "locked8", "locked6", "locked8", "locked7", "locked8", "locked9", "locked9", "locked7", "locked8", "locked9"]

    class Puzzle5(Puzzle):
        def __init__(self):
            super(Puzzle5, self).__init__()
            self.sequence = ["zone7", "zone8", "zone7", "locked10", "zone8", "zone7", "locked10", "locked11", "zone8", "locked11", "locked10", "locked12", "zone8", "locked11", "zone8", "locked13", "zone7", "locked10", "locked12", "locked13", "locked14", "locked11", "locked10", "locked12", "locked13", "locked14", "locked10", "locked14"]

    current_puzzle = Puzzle()

    # Global Reset and Puzzle State Check
    def reset_game():
        global jaily
        jaily = JailyState()
        current_puzzle.reset()

    def puzzle_state_check():
        current_puzzle.update()
        if jaily.game_over:
            if jaily.temperature >= 103.0:
                renpy.jump("game_over_max_temp")
            elif jaily.embarrassment >= 100:
                renpy.jump("game_over_embarrassment")
            elif jaily.trust <= 0:
                renpy.jump("game_over_trust")
            elif jaily.excitement <= 0:
                renpy.jump("game_over_excitement")
            elif jaily.temperature <= adjustable_config["temp_lower_game_over"]:
                renpy.jump("game_over_low_temp")
        elif current_puzzle.current_seq_index >= len(current_puzzle.sequence):
            renpy.jump("outcome_puzzle")

# SCREENS
transform heart_shower(x_start, y_start, x_end, y_end, rotate, scale):
    pos (x_start, y_start)
    rotate rotate
    zoom scale
    alpha 1.0
    linear adjustable_config["heart_shower"]["duration"]:
         pos (x_end, y_end)
         alpha 0.0

screen FlashScreen():
    modal False
    zorder 5000
    timer adjustable_config["heart_shower"]["duration"] action Hide("FlashScreen")
    for data in heart_shower_anim:
        add data["heart_img"] at heart_shower(data["x_start"], data["y_start"], data["x_end"], data["y_end"], data["r_rotate"], data["r_scale"])

screen particles_screen():
    zorder 2000
    timer 0.1 action Function(cleanup_particles) repeat True
    for p in particles:
        $ age = time.time() - p['spawn_time']
        $ current_alpha = 1.0 if age < particle_config["fadeout_start"] else ((particle_config["lifetime"] - age) / max(0.001, (particle_config["lifetime"] - particle_config["fadeout_start"])))
        add p['heart'] at Transform(
            anchor=(0.5, 0.5),
            pos=(p['x'], p['y']),
            zoom=p['zoom'],
            rotate=p['rotate'],
            alpha=current_alpha
        )
    for p in excitement_particles:
        $ age = time.time() - p['spawn_time']
        $ current_alpha = 1.0 if age < particle_config_excitement["fadeout_start"] else ((particle_config_excitement["lifetime"] - age) / max(0.001, (particle_config_excitement["lifetime"] - particle_config_excitement["fadeout_start"])))
        add p['image'] at Transform(
            anchor=(0.5, 0.5),
            pos=(p['x'], p['y']),
            zoom=p['zoom'],
            rotate=p['rotate'],
            alpha=current_alpha
        )
    for p in trust_particles:
        $ age = time.time() - p['spawn_time']
        $ current_alpha = 1.0 if age < particle_config_trust["fadeout_start"] else ((particle_config_trust["lifetime"] - age) / max(0.001, (particle_config_trust["lifetime"] - particle_config_trust["fadeout_start"])))
        add p['image'] at Transform(
            anchor=(0.5, 0.5),
            pos=(p['x'], p['y']),
            zoom=p['zoom'],
            rotate=p['rotate'],
            alpha=current_alpha
        )

screen ParticleManagerScreen():
    zorder 1000
    timer adjustable_config["particle_update_interval"] action Function(update_particle_system) repeat True

screen puzzle_stats_update():
    timer 0.1 action Function(lambda: update_stats(is_interacting())) repeat True

screen game_state_check():
    timer 0.1 action Function(puzzle_state_check) repeat True

screen Primary_stats():
    frame:
        xalign 0.0
        yalign 0.0
        padding (10, 10)
        background None
        style "empty"
        vbox:
            spacing 8
            text "Trust: [int(jaily.trust)]" size 18
            bar value jaily.trust range 100 xmaximum 150
            text "Excitement: [round(jaily.excitement)]" size 18
            bar value jaily.excitement range 100 xmaximum 150
            text "Temperature: [ '{:.2f}'.format(jaily.temperature) ]" size 18
            bar value jaily.temperature range 103.0 xmaximum 150
            text "Embarrassment: [int(jaily.embarrassment)]" size 18
            bar value jaily.embarrassment range 100 xmaximum 150

screen sequence_display():
    frame:
        xalign 0.5
        yalign 0.1
        background "#00000080"
        padding (10, 10)
        text "[', '.join(current_puzzle.sequence)]" size 24 color "#ffffff"

# TouchScreen definitions for each puzzle

screen TouchScreen():
    # This is used for Puzzle1.
    zorder 100
    modal True
    vbox:
        xalign 0.5
        yalign 0.5
        spacing 20
        button:
            style "cyan_cooldown"
            action NullAction()
            hovered SetVariable("clicked_cooldown", True)
            unhovered SetVariable("clicked_cooldown", False)
            text "Cooldown" xalign 0.5 yalign 0.5
        hbox:
            spacing 20
            button:
                style "red_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone1", True)
                unhovered SetVariable("clicked_zone1", False)
                text "Zone1" xalign 0.5 yalign 0.5
            button:
                style "green_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone2", True)
                unhovered SetVariable("clicked_zone2", False)
                text "Zone2" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked1", True)
                unhovered SetVariable("clicked_locked1", False)
                text "Locked1" xalign 0.5 yalign 0.5

screen TouchScreen2():
    # For Puzzle2: supports Zone1, Zone2, Locked1, Locked2.
    zorder 100
    modal True
    vbox:
        xalign 0.5
        yalign 0.5
        spacing 20
        button:
            style "cyan_cooldown"
            action NullAction()
            hovered SetVariable("clicked_cooldown", True)
            unhovered SetVariable("clicked_cooldown", False)
            text "Cooldown" xalign 0.5 yalign 0.5
        hbox:
            spacing 20
            button:
                style "red_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone1", True)
                unhovered SetVariable("clicked_zone1", False)
                text "Zone1" xalign 0.5 yalign 0.5
            button:
                style "green_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone2", True)
                unhovered SetVariable("clicked_zone2", False)
                text "Zone2" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked1", True)
                unhovered SetVariable("clicked_locked1", False)
                text "Locked1" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked2", True)
                unhovered SetVariable("clicked_locked2", False)
                text "Locked2" xalign 0.5 yalign 0.5

screen TouchScreen3():
    # For Puzzle3: supports Zone3, Zone4, Locked3, Locked4, Locked5.
    zorder 100
    modal True
    vbox:
        xalign 0.5
        yalign 0.5
        spacing 20
        button:
            style "cyan_cooldown"
            action NullAction()
            hovered SetVariable("clicked_cooldown", True)
            unhovered SetVariable("clicked_cooldown", False)
            text "Cooldown" xalign 0.5 yalign 0.5
        hbox:
            spacing 20
            button:
                style "red_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone3", True)
                unhovered SetVariable("clicked_zone3", False)
                text "Zone3" xalign 0.5 yalign 0.5
            button:
                style "green_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone4", True)
                unhovered SetVariable("clicked_zone4", False)
                text "Zone4" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked3", True)
                unhovered SetVariable("clicked_locked3", False)
                text "Locked3" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked4", True)
                unhovered SetVariable("clicked_locked4", False)
                text "Locked4" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked5", True)
                unhovered SetVariable("clicked_locked5", False)
                text "Locked5" xalign 0.5 yalign 0.5

screen TouchScreen4():
    # For Puzzle4: supports Zone5, Zone6, Locked6, Locked7, Locked8, Locked9.
    zorder 100
    modal True
    vbox:
        xalign 0.5
        yalign 0.5
        spacing 20
        button:
            style "cyan_cooldown"
            action NullAction()
            hovered SetVariable("clicked_cooldown", True)
            unhovered SetVariable("clicked_cooldown", False)
            text "Cooldown" xalign 0.5 yalign 0.5
        hbox:
            spacing 20
            button:
                style "red_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone5", True)
                unhovered SetVariable("clicked_zone5", False)
                text "Zone5" xalign 0.5 yalign 0.5
            button:
                style "green_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone6", True)
                unhovered SetVariable("clicked_zone6", False)
                text "Zone6" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked6", True)
                unhovered SetVariable("clicked_locked6", False)
                text "Locked6" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked7", True)
                unhovered SetVariable("clicked_locked7", False)
                text "Locked7" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked8", True)
                unhovered SetVariable("clicked_locked8", False)
                text "Locked8" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked9", True)
                unhovered SetVariable("clicked_locked9", False)
                text "Locked9" xalign 0.5 yalign 0.5

screen TouchScreen5():
    # For Puzzle5: supports Zone7, Zone8, Locked10, Locked11, Locked12, Locked13, Locked14.
    zorder 100
    modal True
    vbox:
        xalign 0.5
        yalign 0.5
        spacing 20
        button:
            style "cyan_cooldown"
            action NullAction()
            hovered SetVariable("clicked_cooldown", True)
            unhovered SetVariable("clicked_cooldown", False)
            text "Cooldown" xalign 0.5 yalign 0.5
        hbox:
            spacing 20
            button:
                style "red_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone7", True)
                unhovered SetVariable("clicked_zone7", False)
                text "Zone7" xalign 0.5 yalign 0.5
            button:
                style "green_hotzone"
                action NullAction()
                hovered SetVariable("clicked_zone8", True)
                unhovered SetVariable("clicked_zone8", False)
                text "Zone8" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked10", True)
                unhovered SetVariable("clicked_locked10", False)
                text "Locked10" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked11", True)
                unhovered SetVariable("clicked_locked11", False)
                text "Locked11" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked12", True)
                unhovered SetVariable("clicked_locked12", False)
                text "Locked12" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked13", True)
                unhovered SetVariable("clicked_locked13", False)
                text "Locked13" xalign 0.5 yalign 0.5
            button:
                style "blue_hotzone"
                action NullAction()
                hovered SetVariable("clicked_locked14", True)
                unhovered SetVariable("clicked_locked14", False)
                text "Locked14" xalign 0.5 yalign 0.5

screen overheat_overlay():
    zorder 4999
    timer 0.1 action NullAction() repeat True
    $ temp = jaily.temperature
    if temp <= 102.0:
        $ overlay_alpha = 0.0
    else:
        $ overlay_alpha = (min(temp, 103.0) - 102.0) * 0.25
    add Solid("#ff0000", xysize=(config.screen_width, config.screen_height)) alpha overlay_alpha

# STYLE DEFINITIONS
init python:
    style.red_hotzone = Style(style.button)
    style.red_hotzone.background = "#ffcccc"
    style.red_hotzone.hover_background = "#ffe6e6"
    style.red_hotzone.xysize = (150, 150)
    style.green_hotzone = Style(style.button)
    style.green_hotzone.background = "#ccffcc"
    style.green_hotzone.hover_background = "#e6ffe6"
    style.green_hotzone.xysize = (150, 150)
    style.blue_hotzone = Style(style.button)
    style.blue_hotzone.background = "#ccccff"
    style.blue_hotzone.hover_background = "#e6e6ff"
    style.blue_hotzone.xysize = (150, 150)
    style.cyan_cooldown = Style(style.button)
    style.cyan_cooldown.background = "#00ffff"
    style.cyan_cooldown.hover_background = "#e0ffff"
    style.cyan_cooldown.xysize = (150, 150)


# Consolidated hide for UI elements
label hide_all_ui:
    $ _screens = [
        "TouchScreen", "TouchScreen2", "TouchScreen3",
        "TouchScreen4", "TouchScreen5", "ParticleManagerScreen",
    ]
    python:
        for s in _screens:
            renpy.hide_screen(s)
    return

# LABELS (Game Flow)
label flash_screen:
    show screen FlashScreen
    pause adjustable_config["heart_shower"]["duration"]
    return

label game_over_max_temp:
    call hide_all_ui
    "Game Over: Temperature too high!"
    return

label game_over_embarrassment:
    call hide_all_ui
    "Game Over: Embarrassment reached 100!"
    return

label game_over_trust:
    call hide_all_ui
    "Game Over: Trust has dropped to 0!"
    return

label game_over_excitement:
    call hide_all_ui
    "Game Over: Excitement dropped to 0!"
    return

label game_over_low_temp:
    call hide_all_ui
    "Game Over: Temperature too low!"
    return

label outcome_puzzle:
    hide screen TouchScreen
    hide screen TouchScreen2
    hide screen TouchScreen3
    hide screen TouchScreen4
    hide screen TouchScreen5
    hide screen ParticleManagerScreen
    hide screen particles_screen
    hide screen puzzle_stats_update
    hide screen Primary_stats
    hide screen game_state_check
    hide screen sequence_display
    hide screen overheat_overlay
    "Congratulations! Puzzle completed successfully!"
    $ next_story = "story{}".format(puzzle_stage + 1)
    jump expression next_story

label start:
    show screen Primary_stats
    "This is a story placeholder before the first puzzle."
    show screen overheat_overlay
    jump puzzle1_stage

label story2:
    window show
    show screen Primary_stats
    "This is a story placeholder before the second puzzle."
    jump puzzle2_stage

label story3:
    window show
    show screen Primary_stats
    "This is a story placeholder before the third puzzle."
    jump puzzle3_stage

label story4:
    window show
    show screen Primary_stats
    "This is a story placeholder before the fourth puzzle."
    jump puzzle4_stage

label story5:
    window show
    show screen Primary_stats
    "This is a story placeholder before the fifth puzzle."
    jump puzzle5_stage

label puzzle1_stage:
    $ puzzle_stage = 1
    $ current_puzzle = Puzzle()  # Explicitly set the puzzle instance
    $ reset_game()  # Now reset_game() calls reset() on the current_puzzle
    window hide
    show screen sequence_display
    show screen TouchScreen
    show screen ParticleManagerScreen
    show screen particles_screen
    show screen puzzle_stats_update
    show screen Primary_stats
    show screen game_state_check
    show screen overheat_overlay
    pause

label puzzle2_stage:
    *Place holder for puzzle2

label puzzle3_stage:
    *Place holder for puzzle3

label puzzle4_stage:
    *Place holder for puzzle4

label puzzle5_stage:
    *Place holder for puzzle5
    
label story6:
    window show
    show screen Primary_stats
    "This is a story placeholder for the final part of the game."
